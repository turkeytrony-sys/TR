<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¥‡å¹»å¡ç‰Œå¯¹æˆ˜</title>
    
    <!-- æ·»åŠ è¿™3è¡ŒPWAä»£ç  -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸƒ</text></svg>">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            padding: 5px;
            font-size: 14px;
        }

        #game-container {
            max-width: 100%;
            margin: 0 auto;
        }

        .game-header {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
        }

        .game-header h1 {
            font-size: 18px;
            margin-bottom: 8px;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }

        .opponents-area {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .opponent {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
        }

        .opponent-info {
            margin-bottom: 8px;
        }

        .opponent-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .opponent-stats {
            font-size: 12px;
            color: #ccc;
            display: flex;
            gap: 10px;
        }

        .opponent-blood-cards {
            display: flex;
            gap: 4px;
            margin-top: 5px;
        }

        .blood-card-slot {
            width: 30px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .blood-card-slot.face-up {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .blood-card-slot.empty {
            background: rgba(255,255,255,0.1);
            color: #999;
        }

        .player-area {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .player-info h3 {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .status {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 13px;
            margin-bottom: 10px;
        }

        .section-title {
            font-size: 13px;
            margin: 10px 0 5px 0;
            color: #ffeb3b;
        }

        .cards-container {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            margin: 10px 0;
            padding: 8px 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            min-height: 120px;
            -webkit-overflow-scrolling: touch;
        }

        .card {
            flex: 0 0 auto;
            width: 75px;
            height: 105px;
            background: white;
            border-radius: 6px;
            border: 2px solid #ddd;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 6px;
            margin: 0 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: black;
            position: relative;
        }

        .card:active {
            transform: translateY(-3px);
        }

        .card.selected {
            border-color: #ffeb3b;
            box-shadow: 0 0 8px #ffeb3b;
        }

        .card.spade { border-left: 4px solid #000; }
        .card.heart { border-left: 4px solid #e74c3c; }
        .card.club { border-left: 4px solid #27ae60; }
        .card.diamond { border-left: 4px solid #f39c12; }
        .card.joker { border-left: 4px solid #9b59b6; }

        .card-rank {
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
        }

        .card-suit {
            font-size: 20px;
            text-align: center;
            line-height: 1;
        }

        .card-point {
            font-size: 11px;
            color: #666;
            text-align: center;
        }

        .blood-cards .card, .equipment-cards .card {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .equipment-cards .card {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .card.special::after {
            content: 'âœ¨';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
            background: gold;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 5px gold;
        }

        .blood-cards .card.special::after {
            top: -3px;
            right: -3px;
            font-size: 10px;
            width: 16px;
            height: 16px;
        }

        .card.wild::before {
            content: 'ğŸŒŸ';
            position: absolute;
            top: -5px;
            left: -5px;
            font-size: 12px;
            background: linear-gradient(45deg, #ff6b6b, #ffeb3b, #27ae60);
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 5px gold;
        }

        .card.heart-blood::after {
            content: 'â¤ï¸';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
            background: #e74c3c;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 5px #e74c3c;
        }

        .blood-cards .card.heart-blood::after {
            top: -3px;
            right: -3px;
            font-size: 10px;
            width: 16px;
            height: 16px;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        .action-buttons button {
            padding: 12px 8px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.3s;
            min-height: 44px;
        }

        .action-buttons button:active:not(:disabled) {
            background: #2980b9;
            transform: scale(0.98);
        }

        .action-buttons button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-content {
            background: #2c3e50;
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        .target-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .target-buttons button {
            padding: 12px;
            background: #34495e;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
        }

        .modal-actions button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #confirm-attack {
            background: #e74c3c;
            color: white;
        }

        #cancel-attack {
            background: #7f8c8d;
            color: white;
        }

        #confirm-combo {
            background: #27ae60;
            color: white;
        }

        #confirm-combo:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .hidden {
            display: none !important;
        }

        .game-log {
            background: rgba(0,0,0,0.7);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .game-log h4 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        #log-content {
            font-size: 12px;
            line-height: 1.3;
        }

        .log-entry {
            margin: 4px 0;
            padding: 4px 8px;
            border-left: 2px solid #3498db;
            background: rgba(255,255,255,0.05);
        }

        .card-combo-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .combo-option {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            background: #34495e;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .combo-option.selected {
            border-color: #ffeb3b;
            background: rgba(255, 235, 59, 0.1);
        }

        .combo-option h4 {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .combo-option p {
            font-size: 10px;
            color: #ccc;
        }

        .dying-warning {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            text-align: center;
            animation: pulse 1.5s infinite;
        }

        .victory-message {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }

        .special-card-actions {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(155, 89, 182, 0.3);
            border-radius: 6px;
        }

        .heart-card-actions {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(231, 76, 60, 0.3);
            border-radius: 6px;
        }

        .special-card-actions button, .heart-card-actions button {
            flex: 1;
            padding: 8px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .special-card-actions button:disabled, .heart-card-actions button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .double-click-hint {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 2px;
        }

        .hand-limit-warning {
            background: #f39c12;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            text-align: center;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <header class="game-header">
            <h1>ğŸƒ å¥‡å¹»å¡ç‰Œå¯¹æˆ˜ - å®Œæ•´ä¿®å¤ç‰ˆ</h1>
            <div class="game-info">
                <span>è½®æ¬¡: <span id="round">1</span></span>
                <span>é˜¶æ®µ: <span id="phase">å‡†å¤‡</span></span>
                <button id="new-game" style="padding: 8px 12px; font-size: 12px;">æ–°æ¸¸æˆ</button>
            </div>
        </header>

        <div id="victory-message" class="victory-message hidden"></div>

        <div class="opponents-area" id="opponents-area">
            <!-- åªæœ‰1ä¸ªAIå¯¹æ‰‹ -->
        </div>

        <div class="player-area">
            <div class="player-info">
                <h3>ğŸ‘¤ ä½ çš„åŒºåŸŸ</h3>
                <div class="status">
                    <span>æ‰‹ç‰Œ: <span id="hand-count">0</span>/<span id="max-hand">10</span></span>
                    <span>è¡€ç‰Œ: <span id="blood-count">0</span>/5</span>
                    <span>çŠ¶æ€: <span id="player-status">æ­£å¸¸</span></span>
                </div>
            </div>

            <div id="dying-warning" class="dying-warning hidden">
                ğŸ’€ ä½ å¤„äºæ¿’æ­»çŠ¶æ€ï¼è¯·ä½¿ç”¨çº¢å¿ƒç‰Œè¡¥å……è¡€ç‰ŒåŒºï¼Œå¦åˆ™ä¸‹å›åˆå°†æ­»äº¡ï¼
            </div>

            <div id="hand-limit-warning" class="hand-limit-warning hidden">
                âš ï¸ æ‰‹ç‰Œè¶…è¿‡ä¸Šé™ï¼ç»“æŸå›åˆå‰éœ€è¦å¼ƒ2å¼ ç‰Œæ‘¸1å¼ ç‰Œï¼
            </div>

            <div class="section-title">â¤ï¸ è¡€ç‰ŒåŒº (åŒå‡»æ“ä½œ)</div>
            <div class="cards-container blood-cards" id="blood-cards">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>

            <div class="section-title">ğŸƒ æ‰‹ç‰ŒåŒº (ç‚¹å‡»é€‰æ‹©ï¼ŒåŒå‡»ç‰¹æ®Šç‰Œæ“ä½œ)</div>
            <div class="cards-container hand-cards" id="hand-cards">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>

            <div class="section-title">ğŸ›¡ï¸ è£…å¤‡åŒº</div>
            <div class="cards-container equipment-cards" id="equipment-cards">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>

            <!-- ç‰¹æ®Šç‰Œæ“ä½œåŒºåŸŸ -->
            <div id="special-card-actions" class="special-card-actions hidden">
                <button id="move-to-hand">ğŸƒ ç§»å…¥æ‰‹ç‰Œ</button>
                <button id="move-to-blood">â¤ï¸ æ”¾å›è¡€ç‰Œ</button>
                <button id="cancel-special">å–æ¶ˆ</button>
            </div>

            <!-- çº¢å¿ƒç‰Œæ“ä½œåŒºåŸŸ -->
            <div id="heart-card-actions" class="heart-card-actions hidden">
                <button id="retrieve-heart">ğŸƒ ç§»å…¥æ‰‹ç‰Œ</button>
                <button id="cancel-heart">å–æ¶ˆ</button>
            </div>

            <div class="action-buttons">
                <button id="place-blood-btn" disabled>â¤ï¸ æ”¾ç½®è¡€ç‰Œ</button>
                <button id="attack-btn" disabled>âš”ï¸ æ™®é€šæ”»å‡»</button>
                <button id="special-attack-btn" disabled>âœ¨ ç‰¹æ®Šæ”»å‡»</button>
                <button id="equip-btn" disabled>ğŸ”§ åˆæˆè£…å¤‡</button>
                <button id="discard-btn">ğŸ”„ å¼ƒç‰Œæ‘¸ç‰Œ</button>
                <button id="end-turn">â­ï¸ ç»“æŸå›åˆ</button>
            </div>
        </div>

        <div id="card-selection" class="modal hidden">
            <div class="modal-content">
                <h3>ğŸ¯ é€‰æ‹©æ”»å‡»ç›®æ ‡</h3>
                <div class="target-buttons" id="target-players"></div>
                <div class="modal-actions">
                    <button id="confirm-attack">ç¡®è®¤æ”»å‡»</button>
                    <button id="cancel-attack">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <div id="combo-selection" class="modal hidden">
            <div class="modal-content">
                <h3>ğŸ´ é€‰æ‹©ç‰Œå½¢</h3>
                <div class="card-combo-options" id="combo-options"></div>
                <div class="modal-actions">
                    <button id="confirm-combo" disabled>ç¡®è®¤ç‰Œå½¢</button>
                    <button id="cancel-combo">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <div class="game-log">
            <h4>ğŸ“œ æ¸¸æˆæ—¥å¿—</h4>
            <div id="log-content"></div>
        </div>
    </div>

    <script>
        // å®Œæ•´çš„å¡ç‰Œæ•°æ®
        const CARD_DATA = {
            basic: [
                // é»‘æ¡ƒ â™ ï¸
                { id: 's-2', suit: 'spade', rank: 2, point: 2, name: 'é»‘æ¡ƒ2', type: 'kill' },
                { id: 's-3', suit: 'spade', rank: 3, point: 3, name: 'é»‘æ¡ƒ3', type: 'kill' },
                { id: 's-4', suit: 'spade', rank: 4, point: 4, name: 'é»‘æ¡ƒ4', type: 'kill' },
                { id: 's-5', suit: 'spade', rank: 5, point: 5, name: 'é»‘æ¡ƒ5', type: 'kill' },
                { id: 's-6', suit: 'spade', rank: 6, point: 6, name: 'é»‘æ¡ƒ6', type: 'kill' },
                { id: 's-7', suit: 'spade', rank: 7, point: 7, name: 'é»‘æ¡ƒ7', type: 'kill' },
                { id: 's-8', suit: 'spade', rank: 8, point: 8, name: 'é»‘æ¡ƒ8', type: 'kill' },
                { id: 's-9', suit: 'spade', rank: 9, point: 9, name: 'é»‘æ¡ƒ9', type: 'kill' },
                { id: 's-10', suit: 'spade', rank: 10, point: 10, name: 'é»‘æ¡ƒ10', type: 'kill' },
                { id: 's-J', suit: 'spade', rank: 11, point: 11, name: 'é»‘æ¡ƒJ', type: 'kill' },
                { id: 's-Q', suit: 'spade', rank: 12, point: 12, name: 'é»‘æ¡ƒQ', type: 'kill' },
                { id: 's-K', suit: 'spade', rank: 13, point: 13, name: 'é»‘æ¡ƒK', type: 'kill' },
                { id: 's-A', suit: 'spade', rank: 14, point: 14, name: 'é»‘æ¡ƒA', type: 'kill' },
                
                // çº¢å¿ƒ â™¥ï¸
                { id: 'h-2', suit: 'heart', rank: 2, point: 2, name: 'çº¢å¿ƒ2', type: 'blood' },
                { id: 'h-3', suit: 'heart', rank: 3, point: 3, name: 'çº¢å¿ƒ3', type: 'blood' },
                { id: 'h-4', suit: 'heart', rank: 4, point: 4, name: 'çº¢å¿ƒ4', type: 'blood' },
                { id: 'h-5', suit: 'heart', rank: 5, point: 5, name: 'çº¢å¿ƒ5', type: 'blood' },
                { id: 'h-6', suit: 'heart', rank: 6, point: 6, name: 'çº¢å¿ƒ6', type: 'blood' },
                { id: 'h-7', suit: 'heart', rank: 7, point: 7, name: 'çº¢å¿ƒ7', type: 'blood' },
                { id: 'h-8', suit: 'heart', rank: 8, point: 8, name: 'çº¢å¿ƒ8', type: 'blood' },
                { id: 'h-9', suit: 'heart', rank: 9, point: 9, name: 'çº¢å¿ƒ9', type: 'blood' },
                { id: 'h-10', suit: 'heart', rank: 10, point: 10, name: 'çº¢å¿ƒ10', type: 'blood' },
                { id: 'h-J', suit: 'heart', rank: 11, point: 11, name: 'çº¢å¿ƒJ', type: 'blood' },
                { id: 'h-Q', suit: 'heart', rank: 12, point: 12, name: 'çº¢å¿ƒQ', type: 'blood' },
                { id: 'h-K', suit: 'heart', rank: 13, point: 13, name: 'çº¢å¿ƒK', type: 'blood' },
                { id: 'h-A', suit: 'heart', rank: 14, point: 14, name: 'çº¢å¿ƒA', type: 'blood' },
                
                // æ¢…èŠ± â™£ï¸
                { id: 'c-2', suit: 'club', rank: 2, point: 2, name: 'æ¢…èŠ±2', type: 'support' },
                { id: 'c-3', suit: 'club', rank: 3, point: 3, name: 'æ¢…èŠ±3', type: 'support' },
                { id: 'c-4', suit: 'club', rank: 4, point: 4, name: 'æ¢…èŠ±4', type: 'support' },
                { id: 'c-5', suit: 'club', rank: 5, point: 5, name: 'æ¢…èŠ±5', type: 'support' },
                { id: 'c-6', suit: 'club', rank: 6, point: 6, name: 'æ¢…èŠ±6', type: 'support' },
                { id: 'c-7', suit: 'club', rank: 7, point: 7, name: 'æ¢…èŠ±7', type: 'support' },
                { id: 'c-8', suit: 'club', rank: 8, point: 8, name: 'æ¢…èŠ±8', type: 'support' },
                { id: 'c-9', suit: 'club', rank: 9, point: 9, name: 'æ¢…èŠ±9', type: 'support' },
                { id: 'c-10', suit: 'club', rank: 10, point: 10, name: 'æ¢…èŠ±10', type: 'support' },
                { id: 'c-J', suit: 'club', rank: 11, point: 11, name: 'æ¢…èŠ±J', type: 'support' },
                { id: 'c-Q', suit: 'club', rank: 12, point: 12, name: 'æ¢…èŠ±Q', type: 'support' },
                { id: 'c-K', suit: 'club', rank: 13, point: 13, name: 'æ¢…èŠ±K', type: 'support' },
                { id: 'c-A', suit: 'club', rank: 14, point: 14, name: 'æ¢…èŠ±A', type: 'support' },
                
                // æ–¹å— â™¦ï¸
                { id: 'd-2', suit: 'diamond', rank: 2, point: 2, name: 'æ–¹å—2', type: 'support' },
                { id: 'd-3', suit: 'diamond', rank: 3, point: 3, name: 'æ–¹å—3', type: 'support' },
                { id: 'd-4', suit: 'diamond', rank: 4, point: 4, name: 'æ–¹å—4', type: 'support' },
                { id: 'd-5', suit: 'diamond', rank: 5, point: 5, name: 'æ–¹å—5', type: 'support' },
                { id: 'd-6', suit: 'diamond', rank: 6, point: 6, name: 'æ–¹å—6', type: 'support' },
                { id: 'd-7', suit: 'diamond', rank: 7, point: 7, name: 'æ–¹å—7', type: 'support' },
                { id: 'd-8', suit: 'diamond', rank: 8, point: 8, name: 'æ–¹å—8', type: 'support' },
                { id: 'd-9', suit: 'diamond', rank: 9, point: 9, name: 'æ–¹å—9', type: 'support' },
                { id: 'd-10', suit: 'diamond', rank: 10, point: 10, name: 'æ–¹å—10', type: 'support' },
                { id: 'd-J', suit: 'diamond', rank: 11, point: 11, name: 'æ–¹å—J', type: 'support' },
                { id: 'd-Q', suit: 'diamond', rank: 12, point: 12, name: 'æ–¹å—Q', type: 'support' },
                { id: 'd-K', suit: 'diamond', rank: 13, point: 13, name: 'æ–¹å—K', type: 'support' },
                { id: 'd-A', suit: 'diamond', rank: 14, point: 14, name: 'æ–¹å—A', type: 'support' }
            ],
            
            special: [
                { 
                    id: 'joker-small', 
                    suit: 'joker', 
                    rank: 15, 
                    point: 15, 
                    name: 'å°ç‹', 
                    type: 'special',
                    isWild: true
                },
                { 
                    id: 'joker-big', 
                    suit: 'joker', 
                    rank: 16, 
                    point: 16, 
                    name: 'å¤§ç‹', 
                    type: 'special',
                    isWild: true
                }
            ]
        };

        // ä¿®å¤çš„ç‰Œå½¢å®šä¹‰
        const CARD_COMBOS = {
            straight: {
                name: 'é¡ºå­',
                description: 'n+2å¼ è¿ç»­ç‚¹æ•°çš„ç‰Œï¼Œæ”»å‡»åŠ›ä¸ºç‚¹æ•°ä¹‹å’Œï¼Œé€ æˆä¼¤å®³åå¯æŠ½å–æ‰€æœ‰ç©å®¶ä¸€å¼ æ‰‹ç‰Œ',
                minCards: 4,
                maxCards: null,
                validate: (cards, playerCount = 2) => {
                    const n = playerCount;
                    const requiredCards = n + 2;
                    
                    if (cards.length < requiredCards) return false;
                    
                    const wildCards = cards.filter(c => c.isWild);
                    const normalCards = cards.filter(c => !c.isWild);
                    
                    if (normalCards.length === 0) {
                        return cards.length >= requiredCards;
                    }
                    
                    let points = [...new Set(normalCards.map(c => c.point))];
                    if (points.includes(14)) {
                        points = [...points, 1];
                    }
                    
                    points.sort((a, b) => a - b);
                    
                    if (points.length < 2) return false;
                    
                    const checkConsecutive = (pointsArr, wildCount) => {
                        for (let i = 0; i <= pointsArr.length - requiredCards + wildCount; i++) {
                            let gaps = 0;
                            for (let j = i + 1; j < i + requiredCards - wildCount; j++) {
                                if (j >= pointsArr.length) break;
                                const gap = pointsArr[j] - pointsArr[j-1] - 1;
                                if (gap > 0) {
                                    gaps += gap;
                                }
                            }
                            if (gaps <= wildCount) {
                                return true;
                            }
                        }
                        return false;
                    };
                    
                    return checkConsecutive(points, wildCards.length) && cards.length >= requiredCards;
                },
                calculatePower: (cards) => {
                    const normalCards = cards.filter(c => !c.isWild);
                    const wildCards = cards.filter(c => c.isWild);
                    
                    if (normalCards.length === 0) {
                        return cards.reduce((sum, card) => sum + card.point, 0);
                    }
                    
                    let totalPower = normalCards.reduce((sum, card) => sum + card.point, 0);
                    
                    if (wildCards.length > 0) {
                        const avgPoint = totalPower / normalCards.length;
                        totalPower += wildCards.length * Math.round(avgPoint);
                    }
                    
                    return totalPower;
                },
                effect: 'steal_all_hand_after_damage'
            },

            flushStraight: {
                name: 'åŒèŠ±é¡º',
                description: 'n+2å¼ è¿ç»­ç‚¹æ•°ç›¸åŒèŠ±è‰²çš„ç‰Œï¼Œæ”»å‡»åŠ›ä¸ºç‚¹æ•°ä¹‹å’Œï¼Œé€ æˆä¼¤å®³åå¯æŠ½å–æ‰€æœ‰ç©å®¶æ‰‹ç‰Œå¹¶æ‘¸nå¼ åŸºç¡€ç‰Œ',
                minCards: 4,
                maxCards: null,
                validate: (cards, playerCount = 2) => {
                    const n = playerCount;
                    const requiredCards = n + 2;
                    
                    if (cards.length < requiredCards) return false;
                    
                    const wildCards = cards.filter(c => c.isWild);
                    const normalCards = cards.filter(c => !c.isWild);
                    
                    if (normalCards.length === 0) {
                        return cards.length >= requiredCards;
                    }
                    
                    const suit = normalCards[0].suit;
                    if (!normalCards.every(c => c.suit === suit)) return false;
                    
                    let points = [...new Set(normalCards.map(c => c.point))];
                    if (points.includes(14)) {
                        points = [...points, 1];
                    }
                    
                    points.sort((a, b) => a - b);
                    
                    if (points.length < 2) return false;
                    
                    const checkConsecutive = (pointsArr, wildCount) => {
                        for (let i = 0; i <= pointsArr.length - requiredCards + wildCount; i++) {
                            let gaps = 0;
                            for (let j = i + 1; j < i + requiredCards - wildCount; j++) {
                                if (j >= pointsArr.length) break;
                                const gap = pointsArr[j] - pointsArr[j-1] - 1;
                                if (gap > 0) {
                                    gaps += gap;
                                }
                            }
                            if (gaps <= wildCount) {
                                return true;
                            }
                        }
                        return false;
                    };
                    
                    return checkConsecutive(points, wildCards.length) && cards.length >= requiredCards;
                },
                calculatePower: (cards) => {
                    const normalCards = cards.filter(c => !c.isWild);
                    const wildCards = cards.filter(c => c.isWild);
                    
                    if (normalCards.length === 0) {
                        return cards.reduce((sum, card) => sum + card.point, 0);
                    }
                    
                    let totalPower = normalCards.reduce((sum, card) => sum + card.point, 0);
                    
                    if (wildCards.length > 0) {
                        const avgPoint = totalPower / normalCards.length;
                        totalPower += wildCards.length * Math.round(avgPoint);
                    }
                    
                    return totalPower;
                },
                effect: 'steal_all_hand_and_draw_after_damage'
            },

            royalStraight: {
                name: 'çš‡å®¶é¡º',
                description: 'â™ ï¸10JQKAï¼Œæ”»å‡»åŠ›ä¸ºç‚¹æ•°ä¹‹å’Œï¼Œé€ æˆä¼¤å®³åå¯è·å¾—å¯¹æ–¹æ‰€æœ‰æ‰‹ç‰Œå¹¶æ‘¸ä¸¤å¼ åŸºç¡€ç‰Œ',
                minCards: 5,
                maxCards: 5,
                validate: (cards) => {
                    if (cards.length !== 5) return false;
                    
                    const wildCards = cards.filter(c => c.isWild);
                    const normalCards = cards.filter(c => !c.isWild);
                    
                    if (wildCards.length > 0) return false;
                    
                    if (!normalCards.every(c => c.suit === 'spade')) return false;
                    
                    const requiredRanks = [10, 11, 12, 13, 14];
                    const cardRanks = normalCards.map(c => c.rank).sort((a, b) => a - b);
                    
                    return JSON.stringify(cardRanks) === JSON.stringify(requiredRanks);
                },
                calculatePower: (cards) => cards.reduce((sum, card) => sum + card.point, 0),
                effect: 'take_all_hand_after_damage'
            },

            // ä¿®å¤çš„å¦å…‹ç‰Œå½¢ - æ”¯æŒè¿ç»­å¯¹å­å’Œä¸‡èƒ½ç‰Œ
            tank: {
                name: 'å¦å…‹',
                description: 'è¿ç»­nå¯¹è¿ç»­ç‚¹æ•°çš„å¯¹å­ï¼Œä¸‡èƒ½ç‰Œå¯å……å½“ä»»ä½•ç‚¹æ•°ï¼Œå¯å¯¹n-1åç©å®¶é€ æˆä¼¤å®³',
                minCards: 4,
                maxCards: null,
                validate: (cards, playerCount = 2) => {
                    const n = playerCount;
                    const requiredPairs = n;
                    const requiredCards = requiredPairs * 2;
                    
                    if (cards.length !== requiredCards) return false;
                    if (cards.length % 2 !== 0) return false;
                    
                    const wildCards = cards.filter(c => c.isWild);
                    const normalCards = cards.filter(c => !c.isWild);
                    const totalWilds = wildCards.length;
                    
                    // è·å–æ‰€æœ‰æ™®é€šç‰Œçš„ç‚¹æ•°ï¼ˆæ”¯æŒA=1ï¼‰
                    let normalPoints = [];
                    normalCards.forEach(card => {
                        normalPoints.push(card.point);
                        if (card.point === 14) normalPoints.push(1);
                    });
                    normalPoints = [...new Set(normalPoints)].sort((a, b) => a - b);
                    
                    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¿ç»­çš„requiredPairsä¸ªç‚¹æ•°
                    for (let start = 0; start <= normalPoints.length - requiredPairs; start++) {
                        const sequence = [];
                        for (let i = 0; i < requiredPairs; i++) {
                            sequence.push(normalPoints[start + i]);
                        }
                        
                        // æ£€æŸ¥è¿™ä¸ªåºåˆ—æ˜¯å¦è¿ç»­
                        let isConsecutive = true;
                        for (let i = 0; i < requiredPairs - 1; i++) {
                            if (sequence[i + 1] - sequence[i] !== 1) {
                                isConsecutive = false;
                                break;
                            }
                        }
                        
                        if (isConsecutive) {
                            // æ£€æŸ¥è¿™ä¸ªè¿ç»­åºåˆ—æ˜¯å¦èƒ½ç”¨ç°æœ‰ç‰Œ+ä¸‡èƒ½ç‰Œç»„æˆå¯¹å­
                            let wildsNeeded = 0;
                            let sequenceValid = true;
                            
                            for (const point of sequence) {
                                const pointCards = normalCards.filter(c => 
                                    c.point === point || (c.point === 14 && point === 1)
                                );
                                
                                if (pointCards.length >= 2) {
                                    continue;
                                } else if (pointCards.length === 1) {
                                    wildsNeeded += 1;
                                } else {
                                    wildsNeeded += 2;
                                }
                            }
                            
                            if (wildsNeeded <= totalWilds) {
                                return true;
                            }
                        }
                    }
                    
                    // å¦‚æœæ™®é€šç‰Œç‚¹æ•°ä¸å¤Ÿè¿ç»­ï¼Œæ£€æŸ¥æ˜¯å¦èƒ½ç”¨ä¸‡èƒ½ç‰Œåˆ›å»ºå®Œæ•´è¿ç»­åºåˆ—
                    if (normalPoints.length === 0 && totalWilds >= requiredPairs * 2) {
                        return true;
                    }
                    
                    // æ£€æŸ¥éƒ¨åˆ†è¿ç»­ï¼Œç”¨ä¸‡èƒ½ç‰Œè¡¥å…¨çš„æƒ…å†µ
                    if (normalPoints.length > 0) {
                        const minPoint = Math.min(...normalPoints);
                        const maxPoint = Math.max(...normalPoints);
                        const sequenceLength = maxPoint - minPoint + 1;
                        
                        if (sequenceLength >= requiredPairs) {
                            let wildsNeeded = 0;
                            for (let point = minPoint; point < minPoint + requiredPairs; point++) {
                                const pointCards = normalCards.filter(c => 
                                    c.point === point || (c.point === 14 && point === 1)
                                );
                                
                                if (pointCards.length >= 2) {
                                    continue;
                                } else if (pointCards.length === 1) {
                                    wildsNeeded += 1;
                                } else {
                                    wildsNeeded += 2;
                                }
                            }
                            
                            if (wildsNeeded <= totalWilds) {
                                return true;
                            }
                        }
                    }
                    
                    return false;
                },
                calculatePower: (cards) => {
                    const normalCards = cards.filter(c => !c.isWild);
                    const wildCards = cards.filter(c => c.isWild);
                    
                    let totalPower = normalCards.reduce((sum, card) => sum + card.point, 0);
                    
                    if (wildCards.length > 0) {
                        const avgPoint = normalCards.length > 0 ? totalPower / normalCards.length : 10;
                        totalPower += wildCards.length * Math.round(avgPoint);
                    }
                    
                    return totalPower;
                },
                effect: 'multi_target_attack'
            },

            // ä¿®å¤çš„æ¿ç –ç‰Œå½¢ - æ˜ç¡®æ”¯æŒä¸‡èƒ½ç‰Œç»„åˆ
            brick: {
                name: 'æ¿ç –',
                description: 'ä¸‰å¼ ç›¸åŒç‚¹æ•°çš„ç‰Œï¼Œä¸‡èƒ½ç‰Œå¯å……å½“ä»»ä½•ç‚¹æ•°ï¼Œé€ æˆä¼¤å®³åå¯æ‘¸ä¸€å¼ åŸºç¡€ç‰Œ',
                minCards: 3,
                maxCards: 3,
                validate: (cards) => {
                    if (cards.length !== 3) return false;
                    
                    const wildCards = cards.filter(c => c.isWild);
                    const normalCards = cards.filter(c => !c.isWild);
                    
                    // æ˜ç¡®æ”¯æŒçš„æƒ…å†µï¼š
                    if (normalCards.length === 2 && wildCards.length === 1) {
                        // ä¸¤å¼ æ™®é€šç‰Œ + ä¸€å¼ ä¸‡èƒ½ç‰Œ - æ£€æŸ¥ä¸¤å¼ æ™®é€šç‰Œç‚¹æ•°æ˜¯å¦ç›¸åŒ
                        return normalCards[0].point === normalCards[1].point;
                    }
                    if (normalCards.length === 1 && wildCards.length === 2) {
                        // ä¸€å¼ æ™®é€šç‰Œ + ä¸¤å¼ ä¸‡èƒ½ç‰Œ
                        return true;
                    }
                    if (normalCards.length === 3) {
                        // ä¸‰å¼ ç›¸åŒç‚¹æ•°çš„æ™®é€šç‰Œ
                        return normalCards[0].point === normalCards[1].point && 
                               normalCards[1].point === normalCards[2].point;
                    }
                    if (wildCards.length === 3) {
                        // ä¸‰å¼ ä¸‡èƒ½ç‰Œ
                        return true;
                    }
                    
                    return false;
                },
                calculatePower: (cards) => {
                    const normalCards = cards.filter(c => !c.isWild);
                    const wildCards = cards.filter(c => c.isWild);
                    
                    if (normalCards.length === 0) {
                        return cards.reduce((sum, card) => sum + card.point, 0);
                    }
                    
                    const basePoint = normalCards[0].point;
                    let totalPower = normalCards.reduce((sum, card) => sum + card.point, 0);
                    
                    totalPower += wildCards.length * basePoint;
                    
                    return totalPower;
                },
                effect: 'draw_after_damage'
            }
        };

        // ä¿®å¤å¡ç‰Œå·¥å…·å‡½æ•°
        const CardUtils = {
            getSuitSymbol(suit) {
                const symbols = {
                    'spade': 'â™ ',
                    'heart': 'â™¥', 
                    'club': 'â™£',
                    'diamond': 'â™¦',
                    'joker': 'ğŸƒ'
                };
                return symbols[suit] || suit;
            },

            getRankDisplay(rank) {
                const displays = {
                    11: 'J',
                    12: 'Q', 
                    13: 'K',
                    14: 'A',
                    15: 'å°',
                    16: 'å¤§'
                };
                return displays[rank] || rank.toString();
            },
            
            checkCardCombos(cards, playerCount = 2) {
                const availableCombos = [];
                
                for (const [comboKey, combo] of Object.entries(CARD_COMBOS)) {
                    if (combo.validate(cards, playerCount)) {
                        availableCombos.push({
                            key: comboKey,
                            name: combo.name,
                            description: combo.description,
                            power: combo.calculatePower(cards)
                        });
                    }
                }
                
                return availableCombos;
            },
            
            checkNormalAttack(cards) {
                // ä¿®å¤ï¼šä¸‡èƒ½ç‰Œå¯ä»¥ä½œä¸ºå•å¼ æ”»å‡»ç‰Œ
                if (cards.length === 1 && (cards[0].suit === 'spade' || cards[0].isWild)) {
                    return {
                        type: 'single',
                        name: 'å•å¼ ',
                        power: cards[0].point,
                        description: 'ä¸€å¼ â™ ï¸æˆ–ä¸‡èƒ½ç‰Œï¼Œæ”»å‡»åŠ›ä¸ºç‚¹æ•°'
                    };
                }
                
                // ä¿®å¤ï¼šå¯¹å­æ”»å‡»ï¼ˆä¸¤å¼ ç›¸åŒç‚¹æ•°çš„ç‰Œï¼‰
                if (cards.length === 2) {
                    const hasSpadeOrWild = cards.some(c => c.suit === 'spade' || c.isWild);
                    
                    // ä¿®å¤ï¼šæ£€æŸ¥ç‚¹æ•°åŒ¹é…ï¼ˆè€ƒè™‘ä¸‡èƒ½ç‰Œï¼‰
                    let pointsMatch = false;
                    const normalCards = cards.filter(c => !c.isWild);
                    const wildCards = cards.filter(c => c.isWild);
                    
                    if (normalCards.length === 2) {
                        pointsMatch = normalCards[0].point === normalCards[1].point;
                    } else if (normalCards.length === 1 && wildCards.length === 1) {
                        pointsMatch = true;
                    } else if (wildCards.length === 2) {
                        pointsMatch = true;
                    }
                    
                    if (hasSpadeOrWild && pointsMatch) {
                        let attackPower = 0;
                        if (normalCards.length === 2) {
                            attackPower = normalCards[0].point + normalCards[1].point;
                        } else if (normalCards.length === 1 && wildCards.length === 1) {
                            attackPower = normalCards[0].point * 2;
                        } else if (wildCards.length === 2) {
                            attackPower = wildCards[0].point + wildCards[1].point;
                        }
                        
                        return {
                            type: 'pair',
                            name: 'å¯¹å­',
                            power: attackPower,
                            description: 'ä¸€å¼ â™ ï¸/ä¸‡èƒ½ç‰Œ+ä¸€å¼ åŒç‚¹æ•°ç‰Œï¼Œæ”»å‡»åŠ›ä¸ºç‚¹æ•°ä¹‹å’Œ'
                        };
                    }
                }
                
                return null;
            }
        };

        // æ¸¸æˆçŠ¶æ€ç®¡ç†
        class GameState {
            constructor(playerCount = 2, uiManager) {
                this.playerCount = playerCount;
                this.players = [];
                this.currentPlayerIndex = 0;
                this.round = 1;
                this.phase = 'draw';
                this.basicDeck = [];
                this.specialDeck = [];
                this.discardPile = [];
                this.selectedCards = [];
                this.selectedCombo = null;
                this.gameLog = [];
                this.uiManager = uiManager;
                this.attackUsed = false;
                this.selectedSpecialCard = null;
                this.selectedHeartCard = null;
                this.forceDiscardMode = false;
                this.forceDiscardCount = 2;
                this.initializeGame(playerCount);
            }

            calculateMaxHandCards() {
                return this.playerCount + 8;
            }

            setupDecks(playerCount) {
                this.specialDeck = [];
                CARD_DATA.basic.forEach(card => {
                    const cardCopy = this.createCardCopy(card);
                    cardCopy.isSpecialDeckCard = true;
                    this.specialDeck.push(cardCopy);
                });
                CARD_DATA.special.forEach(card => {
                    const cardCopy = this.createCardCopy(card);
                    cardCopy.isSpecialDeckCard = true;
                    cardCopy.isWild = true;
                    this.specialDeck.push(cardCopy);
                });
                
                this.basicDeck = [];
                for (let i = 0; i < 2; i++) {
                    CARD_DATA.basic.forEach(card => {
                        const cardCopy = this.createCardCopy(card);
                        cardCopy.isSpecialDeckCard = false;
                        this.basicDeck.push(cardCopy);
                    });
                    CARD_DATA.special.forEach(card => {
                        const cardCopy = this.createCardCopy(card);
                        cardCopy.isSpecialDeckCard = false;
                        cardCopy.isWild = true;
                        this.basicDeck.push(cardCopy);
                    });
                }
                
                this.shuffleDeck(this.specialDeck);
                this.shuffleDeck(this.basicDeck);
                this.addLog(`ğŸƒ ç‰Œå åˆå§‹åŒ–å®Œæˆï¼šç‰¹æ®Šç‰Œå ${this.specialDeck.length}å¼ ï¼ŒåŸºç¡€ç‰Œå ${this.basicDeck.length}å¼ `);
            }

            createPlayers(count) {
                this.players = [];
                const maxHandCards = this.calculateMaxHandCards();
                
                this.players.push({
                    id: 'player-0',
                    name: 'ä½ ',
                    handCards: [],
                    bloodCards: [],
                    equipments: [],
                    status: 'normal',
                    maxHandCards: maxHandCards,
                    maxBloodCards: 5,
                    attackBonus: 0,
                    bonusDraws: 0,
                    immuneTo: [],
                    isHuman: true,
                    unconscious: 0
                });
                
                this.players.push({
                    id: 'player-1',
                    name: 'ç”µè„‘å¯¹æ‰‹',
                    handCards: [],
                    bloodCards: [],
                    equipments: [],
                    status: 'normal',
                    maxHandCards: maxHandCards,
                    maxBloodCards: 5,
                    attackBonus: 0,
                    bonusDraws: 0,
                    immuneTo: [],
                    isHuman: false,
                    unconscious: 0
                });
            }

            createCardCopy(card) {
                return {
                    ...card,
                    id: card.id + '-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                    faceUp: false,
                    isSpecialDeckCard: card.isSpecialDeckCard || false,
                    isWild: card.isWild || false
                };
            }

            initializeGame(playerCount) {
                this.setupDecks(playerCount);
                this.createPlayers(playerCount);
                this.dealInitialCards();
                this.addLog('ğŸ® æ¸¸æˆå¼€å§‹ï¼1v1å¯¹æˆ˜');
                this.addLog(`ğŸ“Š æ‰‹ç‰Œä¸Šé™ï¼š${this.calculateMaxHandCards()}å¼  (äººæ•°${this.playerCount} + 8)`);
                this.addLog('ğŸ”„ æ–°åŠŸèƒ½ï¼šçº¢å¿ƒç‰Œå¯ä»¥ç§»å›æ‰‹ç‰Œï¼åŒå‡»è¡€ç‰ŒåŒºçº¢å¿ƒç‰Œæ“ä½œ');
                this.startNewTurn();
            }

            dealInitialCards() {
                this.players.forEach(player => {
                    for (let i = 0; i < 3; i++) {
                        const card = this.drawSpecialCard();
                        if (card) {
                            card.faceUp = false;
                            player.bloodCards.push(card);
                        }
                    }
                    for (let i = 0; i < 2; i++) {
                        const card = this.drawBasicCard();
                        if (card) player.handCards.push(card);
                    }
                });
                this.addLog('âœ… åˆå§‹å‘ç‰Œå®Œæˆï¼');
            }

            isSpecialCard(card) {
                return card.isSpecialDeckCard;
            }

            isWildCard(card) {
                return card.isWild;
            }

            isHeartCard(card) {
                return card.suit === 'heart';
            }

            moveBloodToHand(card) {
                const player = this.currentPlayer;
                const cardIndex = player.bloodCards.indexOf(card);
                
                if (player.bloodCards.length <= 1) {
                    this.addLog('âŒ å¿…é¡»è‡³å°‘ä¿ç•™ä¸€å¼ è¡€ç‰Œï¼');
                    return false;
                }
                
                if (cardIndex > -1) {
                    const bloodCard = player.bloodCards.splice(cardIndex, 1)[0];
                    player.handCards.push(bloodCard);
                    this.addLog(`ğŸƒ ${player.name}å°†è¡€ç‰Œ ${bloodCard.name} ç§»å…¥æ‰‹ç‰ŒåŒº`);
                    return true;
                }
                return false;
            }

            moveHandToBlood(card) {
                const player = this.currentPlayer;
                const cardIndex = player.handCards.indexOf(card);
                
                if (cardIndex > -1) {
                    if (player.bloodCards.length >= player.maxBloodCards) {
                        this.addLog('âŒ è¡€ç‰ŒåŒºå·²æ»¡ï¼');
                        return false;
                    }
                    
                    const handCard = player.handCards.splice(cardIndex, 1)[0];
                    handCard.faceUp = false;
                    player.bloodCards.push(handCard);
                    this.addLog(`â¤ï¸ ${player.name}å°†æ‰‹ç‰Œ ${handCard.name} æ”¾å›è¡€ç‰ŒåŒº`);
                    return true;
                }
                return false;
            }

            retrieveHeartToHand(card) {
                const player = this.currentPlayer;
                const cardIndex = player.bloodCards.indexOf(card);
                
                if (player.bloodCards.length <= 1) {
                    this.addLog('âŒ å¿…é¡»è‡³å°‘ä¿ç•™ä¸€å¼ è¡€ç‰Œï¼');
                    return false;
                }
                
                if (cardIndex > -1 && this.isHeartCard(card)) {
                    const heartCard = player.bloodCards.splice(cardIndex, 1)[0];
                    player.handCards.push(heartCard);
                    this.addLog(`ğŸƒ ${player.name}å°†çº¢å¿ƒè¡€ç‰Œ ${heartCard.name} ç§»å…¥æ‰‹ç‰ŒåŒº`);
                    return true;
                }
                return false;
            }

            startNewTurn() {
                this.phase = 'draw';
                this.selectedCards = [];
                this.selectedCombo = null;
                this.attackUsed = false;
                this.selectedSpecialCard = null;
                this.selectedHeartCard = null;
                this.forceDiscardMode = false;
                this.forceDiscardCount = 2;
                
                const player = this.currentPlayer;
                
                if (this.checkGameEnd()) {
                    return;
                }
                
                if (player.status === 'dying') {
                    this.handleDyingState(player);
                    return;
                }
                
                if (player.unconscious > 0) {
                    player.unconscious--;
                    this.addLog(`ğŸ’¤ ${player.name}æ˜è¿·ä¸­ï¼Œè·³è¿‡å›åˆ`);
                    if (player.unconscious === 0) {
                        player.status = 'normal';
                        this.addLog(`âœ… ${player.name}ä»æ˜è¿·ä¸­é†’æ¥`);
                    }
                    this.nextTurn();
                    return;
                }
                
                this.addLog(`ğŸ¯ ${player.name}çš„å›åˆå¼€å§‹`);
                this.drawPhase();
            }

            handleDyingState(player) {
                this.addLog(`ğŸ’€ ${player.name}å¤„äºæ¿’æ­»çŠ¶æ€ï¼`);
                
                if (player.isHuman) {
                    this.addLog('âš ï¸ è¯·ä½¿ç”¨çº¢å¿ƒç‰Œè¡¥å……è¡€ç‰ŒåŒºï¼Œå¦åˆ™å°†æ­»äº¡ï¼');
                    if (this.uiManager) {
                        this.uiManager.showDyingWarning();
                    }
                } else {
                    const heartCards = player.handCards.filter(card => card.suit === 'heart');
                    if (heartCards.length > 0) {
                        const heartCard = heartCards[0];
                        const cardIndex = player.handCards.indexOf(heartCard);
                        if (cardIndex > -1) {
                            const bloodCard = player.handCards.splice(cardIndex, 1)[0];
                            bloodCard.faceUp = false;
                            player.bloodCards.push(bloodCard);
                            player.status = 'normal';
                            this.addLog(`ğŸ¤– ${player.name}ä½¿ç”¨ ${bloodCard.name} è‡ªæ•‘ï¼Œè„±ç¦»æ¿’æ­»çŠ¶æ€`);
                        }
                    } else {
                        player.status = 'dead';
                        this.addLog(`ğŸ’€ ${player.name}æ²¡æœ‰çº¢å¿ƒç‰Œï¼Œæ­»äº¡ï¼`);
                        this.checkGameEnd();
                    }
                }
            }

            drawPhase() {
                const player = this.currentPlayer;
                
                if (player.status === 'dying') {
                    this.phase = 'main';
                    if (this.uiManager) {
                        this.uiManager.render();
                    }
                    return;
                }
                
                let drawCount = 2 + (player.bonusDraws || 0);
                
                for (let i = 0; i < drawCount; i++) {
                    const card = this.drawBasicCard();
                    if (card) player.handCards.push(card);
                }
                
                this.addLog(`ğŸƒ ${player.name}è‡ªåŠ¨æ‘¸äº†${drawCount}å¼ ç‰Œ`);
                this.phase = 'main';

                if (this.uiManager) {
                    this.uiManager.render();
                }

                if (!player.isHuman) {
                    this.executeAITurn();
                }
            }

            async executeAITurn() {
                const player = this.currentPlayer;
                
                if (player.status === 'dying') {
                    this.addLog(`ğŸ¤– ${player.name}æ¿’æ­»çŠ¶æ€ï¼Œç»“æŸå›åˆ`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.nextTurn();
                    return;
                }
                
                this.addLog(`ğŸ¤– ${player.name}æ­£åœ¨æ€è€ƒ...`);
                
                if (player.handCards.length > player.maxHandCards) {
                    for (let i = 0; i < 2; i++) {
                        if (player.handCards.length > 0) {
                            const discardedCard = player.handCards.pop();
                            this.discardPile.push(discardedCard);
                            this.addLog(`ğŸ¤– ${player.name}å¼ƒæ‰äº† ${discardedCard.name}`);
                        }
                    }
                    const newCard = this.drawBasicCard();
                    if (newCard) {
                        player.handCards.push(newCard);
                        this.addLog(`ğŸ¤– ${player.name}æ‘¸äº†ä¸€å¼ ç‰Œ`);
                    }
                }

                const heartCards = player.handCards.filter(card => card.suit === 'heart');
                if (heartCards.length > 0 && player.bloodCards.length < player.maxBloodCards) {
                    const heartCard = heartCards[0];
                    const cardIndex = player.handCards.indexOf(heartCard);
                    if (cardIndex > -1) {
                        const bloodCard = player.handCards.splice(cardIndex, 1)[0];
                        bloodCard.faceUp = false;
                        player.bloodCards.push(bloodCard);
                        this.addLog(`ğŸ¤– ${player.name}æ”¾ç½® ${bloodCard.name} åˆ°è¡€ç‰ŒåŒº`);
                    }
                }

                const attackablePlayers = this.players.filter(p => 
                    p !== player && p.status !== 'unconscious' && p.status !== 'dead' && p.bloodCards.length > 0
                );

                if (attackablePlayers.length > 0 && !this.attackUsed) {
                    const target = attackablePlayers[0];
                    
                    let attackCards = [];
                    const spadeCards = player.handCards.filter(card => card.suit === 'spade');
                    const wildCards = player.handCards.filter(card => this.isWildCard(card));
                    
                    for (const spadeCard of [...spadeCards, ...wildCards]) {
                        const samePointCards = player.handCards.filter(card => 
                            (card.point === spadeCard.point || card.isWild) && card !== spadeCard
                        );
                        if (samePointCards.length > 0) {
                            attackCards = [spadeCard, samePointCards[0]];
                            break;
                        }
                    }
                    
                    if (attackCards.length === 0 && (spadeCards.length > 0 || wildCards.length > 0)) {
                        attackCards = [spadeCards[0] || wildCards[0]];
                    }
                    
                    if (attackCards.length > 0) {
                        const attackPower = attackCards.reduce((sum, card) => sum + card.point, 0);
                        const defensePower = target.bloodCards[0]?.point || 0;

                        if (attackPower > defensePower) {
                            attackCards.forEach(card => {
                                const cardIndex = player.handCards.indexOf(card);
                                if (cardIndex > -1) {
                                    const usedCard = player.handCards.splice(cardIndex, 1)[0];
                                    this.discardPile.push(usedCard);
                                }
                            });

                            const gainedCard = target.bloodCards.shift();
                            if (gainedCard) {
                                player.handCards.push(gainedCard);
                                this.addLog(`ğŸ¤– ${player.name}æ”»å‡» ${target.name} æˆåŠŸï¼è·å¾— ${gainedCard.name}`);
                            }
                        } else {
                            attackCards.forEach(card => {
                                const cardIndex = player.handCards.indexOf(card);
                                if (cardIndex > -1) {
                                    const usedCard = player.handCards.splice(cardIndex, 1)[0];
                                    this.discardPile.push(usedCard);
                                }
                            });
                            this.addLog(`ğŸ¤– ${player.name}æ”»å‡» ${target.name} å¤±è´¥`);
                        }
                        this.attackUsed = true;
                    }
                }

                this.addLog(`ğŸ¤– ${player.name}ç»“æŸå›åˆ`);
                
                if (this.uiManager) {
                    this.uiManager.render();
                }
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                this.nextTurn();
            }

            nextTurn() {
                const currentPlayer = this.currentPlayer;
                
                if (currentPlayer.status === 'dying' && currentPlayer.isHuman) {
                    const hasHeartCards = currentPlayer.handCards.some(card => card.suit === 'heart');
                    if (!hasHeartCards) {
                        currentPlayer.status = 'dead';
                        this.addLog(`ğŸ’€ ${currentPlayer.name}æ²¡æœ‰çº¢å¿ƒç‰Œï¼Œæ­»äº¡ï¼`);
                        this.checkGameEnd();
                    }
                }
                
                this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
                
                if (this.currentPlayerIndex === 0) {
                    this.round++;
                }
                
                this.startNewTurn();
                
                if (this.uiManager) {
                    this.uiManager.render();
                }
            }

            checkGameEnd() {
                const alivePlayers = this.players.filter(p => p.status !== 'dead');
                if (alivePlayers.length === 1) {
                    const winner = alivePlayers[0];
                    this.addLog(`ğŸ‰ æ¸¸æˆç»“æŸï¼${winner.name}è·èƒœï¼`);
                    if (this.uiManager) {
                        this.uiManager.showVictory(winner.name);
                        this.uiManager.disableAllActions();
                    }
                    return true;
                }
                return false;
            }

            drawBasicCard() {
                if (this.basicDeck.length === 0) {
                    this.reshuffleBasicDeck();
                }
                
                if (this.basicDeck.length === 0) {
                    this.addLog('âŒ æ— ç‰Œå¯æ‘¸ï¼');
                    return null;
                }
                
                const card = this.basicDeck.pop();
                return card;
            }

            drawSpecialCard() {
                if (this.specialDeck.length === 0) {
                    this.addLog('âŒ ç‰¹æ®Šç‰Œå †å·²ç©ºï¼');
                    return null;
                }
                return this.specialDeck.pop();
            }

            reshuffleBasicDeck() {
                const remainingBasicCards = [...this.basicDeck];
                const discardedCards = [...this.discardPile];
                
                this.basicDeck = [...remainingBasicCards, ...discardedCards];
                this.discardPile = [];
                
                if (this.basicDeck.length > 0) {
                    this.shuffleDeck(this.basicDeck);
                    this.addLog(`ğŸ”„ é‡æ–°æ´—ç‰Œï¼åŸºç¡€ç‰Œ:${remainingBasicCards.length}å¼  + å¼ƒç‰Œ:${discardedCards.length}å¼  = æ–°ç‰Œå †${this.basicDeck.length}å¼ `);
                } else {
                    this.addLog('âš ï¸ æ‰€æœ‰ç‰Œéƒ½åœ¨ç©å®¶æ‰‹ä¸­ï¼Œæ— æ³•æ´—ç‰Œ');
                }
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            placeBloodCard(card) {
                const player = this.currentPlayer;
                if (player.bloodCards.length >= player.maxBloodCards) {
                    this.addLog('âŒ è¡€ç‰ŒåŒºå·²æ»¡ï¼');
                    return false;
                }
                
                const cardIndex = player.handCards.indexOf(card);
                if (cardIndex > -1) {
                    const bloodCard = player.handCards.splice(cardIndex, 1)[0];
                    bloodCard.faceUp = false;
                    player.bloodCards.push(bloodCard);
                    this.addLog(`â¤ï¸ æ”¾ç½® ${bloodCard.name} åˆ°è¡€ç‰ŒåŒº`);
                    
                    if (player.status === 'dying') {
                        player.status = 'normal';
                        this.addLog(`âœ… ${player.name}è„±ç¦»æ¿’æ­»çŠ¶æ€`);
                        if (this.uiManager) {
                            this.uiManager.hideDyingWarning();
                        }
                    }
                    return true;
                }
                return false;
            }

            selectSpecialCard(card) {
                this.selectedSpecialCard = card;
            }

            selectHeartCard(card) {
                this.selectedHeartCard = card;
            }

            performNormalAttack(targetId, cards) {
                const attacker = this.currentPlayer;
                const target = this.players.find(p => p.id === targetId);
                
                if (!target || target.status === 'unconscious' || target.status === 'dead') {
                    alert('ç›®æ ‡ç©å®¶æ— æ³•è¢«æ”»å‡»ï¼');
                    return false;
                }

                const normalAttack = CardUtils.checkNormalAttack(cards);
                if (!normalAttack) {
                    alert('è¯·é€‰æ‹©å•å¼ é»‘æ¡ƒç‰Œæˆ–å¯¹å­è¿›è¡Œæ™®é€šæ”»å‡»ï¼');
                    return false;
                }

                const attackPower = normalAttack.power;
                const defensePower = target.bloodCards[0]?.point || 0;

                this.addLog(`âš”ï¸ ${attacker.name}ä½¿ç”¨ ${normalAttack.name} æ”»å‡» ${target.name}`);
                this.addLog(`ğŸ“Š æ”»å‡»åŠ›: ${attackPower} vs é˜²å¾¡åŠ›: ${defensePower}`);

                cards.forEach(card => {
                    const cardIndex = attacker.handCards.indexOf(card);
                    if (cardIndex > -1) {
                        const usedCard = attacker.handCards.splice(cardIndex, 1)[0];
                        this.discardPile.push(usedCard);
                        this.addLog(`ğŸ—‘ï¸ ${usedCard.name}è¿›å…¥å¼ƒç‰Œå †`);
                    }
                });

                if (attackPower > defensePower) {
                    const gainedCard = target.bloodCards.shift();
                    if (gainedCard) {
                        attacker.handCards.push(gainedCard);
                        this.addLog(`ğŸ‰ è·å¾—äº†${gainedCard.name}ï¼`);
                    }

                    if (target.bloodCards.length === 0) {
                        target.status = 'dying';
                        this.addLog(`ğŸ’€ ${target.name}è¿›å…¥æ¿’æ­»çŠ¶æ€ï¼`);
                    }
                    
                    this.attackUsed = true;
                    return true;
                } else {
                    this.addLog('ğŸ’¥ æ”»å‡»å¤±è´¥ï¼');
                    this.attackUsed = true;
                    return false;
                }
            }

            performSpecialAttack(targetId, comboKey) {
                const attacker = this.currentPlayer;
                const target = this.players.find(p => p.id === targetId);
                const combo = CARD_COMBOS[comboKey];
                
                if (!target || target.status === 'unconscious' || target.status === 'dead') {
                    alert('ç›®æ ‡ç©å®¶æ— æ³•è¢«æ”»å‡»ï¼');
                    return false;
                }

                const attackPower = combo.calculatePower(this.selectedCards);
                const defensePower = target.bloodCards[0]?.point || 0;

                this.addLog(`âœ¨ ${attacker.name}ä½¿ç”¨ ${combo.name} æ”»å‡» ${target.name}`);
                this.addLog(`ğŸ“Š æ”»å‡»åŠ›: ${attackPower} vs é˜²å¾¡åŠ›: ${defensePower}`);

                this.selectedCards.forEach(card => {
                    const index = attacker.handCards.indexOf(card);
                    if (index > -1) {
                        const usedCard = attacker.handCards.splice(index, 1)[0];
                        this.discardPile.push(usedCard);
                        this.addLog(`ğŸ—‘ï¸ ${usedCard.name}è¿›å…¥å¼ƒç‰Œå †`);
                    }
                });

                if (attackPower > defensePower) {
                    const gainedCard = target.bloodCards.shift();
                    if (gainedCard) {
                        attacker.handCards.push(gainedCard);
                        this.addLog(`ğŸ‰ è·å¾—äº†${gainedCard.name}ï¼`);
                    }

                    this.executeComboEffect(combo, attacker, target);
                    
                    if (target.bloodCards.length === 0) {
                        target.status = 'dying';
                        this.addLog(`ğŸ’€ ${target.name}è¿›å…¥æ¿’æ­»çŠ¶æ€ï¼`);
                    }
                    return true;
                } else {
                    this.addLog('ğŸ’¥ æ”»å‡»å¤±è´¥ï¼');
                    return false;
                }
            }

            executeComboEffect(combo, attacker, target) {
                const n = this.players.filter(p => p.status !== 'dead').length;
                
                switch(combo.effect) {
                    case 'steal_all_hand_after_damage':
                        this.players.forEach(player => {
                            if (player !== attacker && player.status !== 'dead') {
                                if (player.handCards.length > 0) {
                                    const stolenCard = player.handCards.pop();
                                    attacker.handCards.push(stolenCard);
                                    this.addLog(`ğŸƒ ${attacker.name}ä»${player.name}å¤„æŠ½å–äº†${stolenCard.name}`);
                                } else if (player.bloodCards.length > 0) {
                                    const stolenCard = player.bloodCards[0];
                                    player.bloodCards.splice(0, 1);
                                    attacker.handCards.push(stolenCard);
                                    this.addLog(`ğŸƒ ${attacker.name}ä»${player.name}å¤„æŠ½å–äº†è¡€ç‰Œ${stolenCard.name}`);
                                }
                            }
                        });
                        break;
                        
                    case 'steal_all_hand_and_draw_after_damage':
                        this.players.forEach(player => {
                            if (player !== attacker && player.status !== 'dead') {
                                if (player.handCards.length > 0) {
                                    const stolenCard = player.handCards.pop();
                                    attacker.handCards.push(stolenCard);
                                    this.addLog(`ğŸƒ ${attacker.name}ä»${player.name}å¤„æŠ½å–äº†${stolenCard.name}`);
                                } else if (player.bloodCards.length > 0) {
                                    const stolenCard = player.bloodCards[0];
                                    player.bloodCards.splice(0, 1);
                                    attacker.handCards.push(stolenCard);
                                    this.addLog(`ğŸƒ ${attacker.name}ä»${player.name}å¤„æŠ½å–äº†è¡€ç‰Œ${stolenCard.name}`);
                                }
                            }
                        });
                        for (let i = 0; i < n; i++) {
                            const newCard = this.drawBasicCard();
                            if (newCard) {
                                attacker.handCards.push(newCard);
                            }
                        }
                        this.addLog(`ğŸƒ ${attacker.name}æ‘¸äº†${n}å¼ åŸºç¡€ç‰Œ`);
                        break;
                        
                    case 'take_all_hand_after_damage':
                        if (target.handCards.length > 0) {
                            target.handCards.forEach(card => {
                                attacker.handCards.push(card);
                            });
                            this.addLog(`ğŸƒ ${attacker.name}è·å¾—äº†${target.name}çš„æ‰€æœ‰æ‰‹ç‰Œ`);
                            target.handCards = [];
                            
                            for (let i = 0; i < 2; i++) {
                                const newCard = this.drawBasicCard();
                                if (newCard) attacker.handCards.push(newCard);
                            }
                            this.addLog(`ğŸƒ ${attacker.name}æ‘¸äº†2å¼ åŸºç¡€ç‰Œ`);
                        } else if (target.bloodCards.length > 0) {
                            const stolenCard = target.bloodCards[0];
                            target.bloodCards.splice(0, 1);
                            attacker.handCards.push(stolenCard);
                            this.addLog(`ğŸƒ ${attacker.name}ä»${target.name}å¤„æŠ½å–äº†è¡€ç‰Œ${stolenCard.name}`);
                            
                            for (let i = 0; i < 3; i++) {
                                const newCard = this.drawBasicCard();
                                if (newCard) attacker.handCards.push(newCard);
                            }
                            this.addLog(`ğŸƒ ${attacker.name}æ‘¸äº†3å¼ åŸºç¡€ç‰Œ`);
                        }
                        break;
                        
                    case 'multi_target_attack':
                        const attackPower = combo.calculatePower(this.selectedCards);
                        const targetCount = n - 1;
                        const damagePerTarget = Math.floor(attackPower / targetCount);
                        
                        this.otherPlayers.slice(0, targetCount).forEach(player => {
                            if (player.bloodCards.length > 0 && damagePerTarget > player.bloodCards[0].point) {
                                const gainedCard = player.bloodCards.shift();
                                attacker.handCards.push(gainedCard);
                                this.addLog(`ğŸ¯ ${attacker.name}å¯¹${player.name}é€ æˆ${damagePerTarget}ç‚¹ä¼¤å®³ï¼Œè·å¾—${gainedCard.name}`);
                                
                                if (player.handCards.length > 0) {
                                    const discardedCard = player.handCards.pop();
                                    this.discardPile.push(discardedCard);
                                    this.addLog(`ğŸ—‘ï¸ ${attacker.name}å¼ƒç½®äº†${player.name}çš„${discardedCard.name}`);
                                }
                            }
                        });
                        break;
                        
                    case 'draw_after_damage':
                        const newCard = this.drawBasicCard();
                        if (newCard) {
                            attacker.handCards.push(newCard);
                            this.addLog(`ğŸƒ ${attacker.name}ä½¿ç”¨æ¿ç –æ‘¸äº†ä¸€å¼ åŸºç¡€ç‰Œ`);
                        }
                        break;
                }
            }

            enforceHandLimit() {
                const player = this.currentPlayer;
                if (player.handCards.length <= player.maxHandCards) {
                    this.forceDiscardMode = false;
                    return true;
                }
                return false;
            }

            performForceDiscardDraw() {
                const player = this.currentPlayer;
                if (this.selectedCards.length !== 2) {
                    alert('è¯·é€‰æ‹©æ­£å¥½2å¼ ç‰Œå¼ƒæ‰ï¼');
                    return false;
                }

                this.selectedCards.forEach(card => {
                    const index = player.handCards.indexOf(card);
                    if (index > -1) {
                        const discardedCard = player.handCards.splice(index, 1)[0];
                        this.discardPile.push(discardedCard);
                        this.addLog(`ğŸ—‘ï¸ å¼ƒæ‰äº† ${discardedCard.name}`);
                    }
                });

                this.selectedCards = [];
                
                const newCard = this.drawBasicCard();
                if (newCard) {
                    player.handCards.push(newCard);
                    this.addLog(`ğŸƒ æ‘¸äº†ä¸€å¼ ç‰Œ`);
                }

                this.forceDiscardMode = false;
                
                return true;
            }

            get currentPlayer() { 
                return this.players[this.currentPlayerIndex]; 
            }
            
            get otherPlayers() { 
                return this.players.filter((_, i) => i !== this.currentPlayerIndex && this.players[i].status !== 'dead'); 
            }

            addLog(message) {
                this.gameLog.push({ 
                    time: new Date().toLocaleTimeString(), 
                    message: message 
                });
                if (this.gameLog.length > 30) {
                    this.gameLog.shift();
                }
                
                if (this.uiManager) {
                    this.uiManager.renderLog();
                }
            }
        };

        // UI ç®¡ç†å™¨
        class UIManager {
            constructor(gameState) {
                this.gameState = gameState;
                this.gameState.uiManager = this;
                this.selectedTarget = null;
                this.selectedCombo = null;
                this.lastClickTime = 0;
                this.doubleClickDelay = 300;
                this.initializeUI();
            }

            initializeUI() {
                this.bindEvents();
                this.render();
            }

            bindEvents() {
                document.getElementById('new-game').addEventListener('click', () => {
                    this.gameState = new GameState(2, this);
                    this.render();
                });

                document.getElementById('place-blood-btn').addEventListener('click', () => {
                    this.handlePlaceBlood();
                });

                document.getElementById('attack-btn').addEventListener('click', () => {
                    this.handleNormalAttack();
                });

                document.getElementById('special-attack-btn').addEventListener('click', () => {
                    this.handleSpecialAttack();
                });

                document.getElementById('discard-btn').addEventListener('click', () => {
                    this.handleDiscardDraw();
                });

                document.getElementById('end-turn').addEventListener('click', () => {
                    this.handleEndTurn();
                });

                document.getElementById('confirm-attack').addEventListener('click', () => {
                    this.confirmNormalAttack();
                });

                document.getElementById('cancel-attack').addEventListener('click', () => {
                    this.cancelAttack();
                });

                document.getElementById('confirm-combo').addEventListener('click', () => {
                    this.confirmComboSelection();
                });

                document.getElementById('cancel-combo').addEventListener('click', () => {
                    this.cancelComboSelection();
                });

                document.getElementById('move-to-hand').addEventListener('click', () => {
                    this.handleMoveToHand();
                });

                document.getElementById('move-to-blood').addEventListener('click', () => {
                    this.handleMoveToBlood();
                });

                document.getElementById('cancel-special').addEventListener('click', () => {
                    this.cancelSpecialCardSelection();
                });

                document.getElementById('retrieve-heart').addEventListener('click', () => {
                    this.handleRetrieveHeart();
                });

                document.getElementById('cancel-heart').addEventListener('click', () => {
                    this.cancelHeartCardSelection();
                });
            }

            showDyingWarning() {
                document.getElementById('dying-warning').classList.remove('hidden');
            }

            hideDyingWarning() {
                document.getElementById('dying-warning').classList.add('hidden');
            }

            showHandLimitWarning() {
                document.getElementById('hand-limit-warning').classList.remove('hidden');
            }

            hideHandLimitWarning() {
                document.getElementById('hand-limit-warning').classList.add('hidden');
            }

            showVictory(winnerName) {
                const victoryMessage = document.getElementById('victory-message');
                victoryMessage.textContent = `ğŸ‰ ${winnerName} è·èƒœï¼`;
                victoryMessage.classList.remove('hidden');
            }

            disableAllActions() {
                document.getElementById('place-blood-btn').disabled = true;
                document.getElementById('attack-btn').disabled = true;
                document.getElementById('special-attack-btn').disabled = true;
                document.getElementById('equip-btn').disabled = true;
                document.getElementById('discard-btn').disabled = true;
                document.getElementById('end-turn').disabled = true;
                document.getElementById('special-card-actions').classList.add('hidden');
                document.getElementById('heart-card-actions').classList.add('hidden');
            }

            handleEndTurn() {
                if (this.gameState.currentPlayer.isHuman) {
                    const player = this.gameState.currentPlayer;
                    if (player.handCards.length > player.maxHandCards) {
                        this.gameState.forceDiscardMode = true;
                        this.gameState.addLog(`âš ï¸ å›åˆç»“æŸï¼æ‰‹ç‰Œè¶…è¿‡ä¸Šé™${player.maxHandCards}å¼ ï¼Œéœ€è¦å¼ƒ2å¼ ç‰Œå¹¶æ‘¸1å¼ ç‰Œ`);
                        this.render();
                        return;
                    }
                    
                    this.gameState.nextTurn();
                    this.render();
                }
            }

            render() {
                this.renderPlayerArea();
                this.renderOpponents();
                this.renderGameInfo();
                this.renderLog();
                this.updateActionButtons();
                
                if (this.gameState.currentPlayer.status === 'dying' && this.gameState.currentPlayer.isHuman) {
                    this.showDyingWarning();
                } else {
                    this.hideDyingWarning();
                }
                
                if (this.gameState.forceDiscardMode && this.gameState.currentPlayer.isHuman) {
                    this.showHandLimitWarning();
                } else {
                    this.hideHandLimitWarning();
                }
            }

            renderPlayerArea() {
                const player = this.gameState.currentPlayer;
                
                document.getElementById('hand-count').textContent = player.handCards.length;
                document.getElementById('max-hand').textContent = player.maxHandCards;
                document.getElementById('blood-count').textContent = player.bloodCards.length;
                document.getElementById('player-status').textContent = this.getStatusText(player.status);

                this.renderCards('hand-cards', player.handCards, player.isHuman);
                this.renderCards('blood-cards', player.bloodCards, player.isHuman);
            }

            renderOpponents() {
                const opponentsArea = document.getElementById('opponents-area');
                opponentsArea.innerHTML = '';

                this.gameState.otherPlayers.forEach(player => {
                    const opponentElement = document.createElement('div');
                    opponentElement.className = 'opponent';
                    
                    let bloodCardsHTML = '';
                    for (let i = 0; i < player.maxBloodCards; i++) {
                        if (i < player.bloodCards.length) {
                            const card = player.bloodCards[i];
                            const isFaceUp = card.faceUp || false;
                            bloodCardsHTML += `
                                <div class="blood-card-slot ${isFaceUp ? 'face-up' : ''}">
                                    ${isFaceUp ? card.point + 'ç‚¹' : '?'}
                                </div>
                            `;
                        } else {
                            bloodCardsHTML += '<div class="blood-card-slot empty">ç©º</div>';
                        }
                    }

                    opponentElement.innerHTML = `
                        <div class="opponent-info">
                            <div class="opponent-name">${player.name} ${player.status === 'dead' ? 'ğŸ’€' : 'ğŸ¤–'}</div>
                            <div class="opponent-stats">
                                æ‰‹ç‰Œ:${player.handCards.length} 
                                çŠ¶æ€:${this.getStatusText(player.status)}
                            </div>
                        </div>
                        <div class="opponent-blood-cards">${bloodCardsHTML}</div>
                    `;
                    opponentsArea.appendChild(opponentElement);
                });
            }

            renderCards(containerId, cards, selectable) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';

                cards.forEach(card => {
                    const cardElement = document.createElement('div');
                    const isSpecial = this.gameState.isSpecialCard(card);
                    const isWild = this.gameState.isWildCard(card);
                    const isHeart = this.gameState.isHeartCard(card);
                    
                    cardElement.className = `card ${card.suit} ${this.gameState.selectedCards.includes(card) ? 'selected' : ''} ${isSpecial ? 'special' : ''} ${isWild ? 'wild' : ''} ${isHeart && containerId === 'blood-cards' ? 'heart-blood' : ''}`;
                    
                    let doubleClickHint = '';
                    if (containerId === 'blood-cards' && (isSpecial || isHeart)) {
                        doubleClickHint = '<div class="double-click-hint">åŒå‡»æ“ä½œ</div>';
                    }
                    
                    cardElement.innerHTML = `
                        <div class="card-rank">${CardUtils.getRankDisplay(card.rank)}</div>
                        <div class="card-suit">${CardUtils.getSuitSymbol(card.suit)}</div>
                        <div class="card-point">${card.point}ç‚¹</div>
                        ${doubleClickHint}
                    `;

                    if (selectable) {
                        cardElement.addEventListener('click', (e) => {
                            const currentTime = new Date().getTime();
                            const timeDiff = currentTime - this.lastClickTime;
                            
                            if (timeDiff < this.doubleClickDelay && this.lastClickedCard === card) {
                                if (isSpecial || isHeart) {
                                    this.handleBloodCardDoubleClick(card, containerId);
                                }
                                this.lastClickTime = 0;
                                this.lastClickedCard = null;
                            } else {
                                this.lastClickTime = currentTime;
                                this.lastClickedCard = card;
                                
                                if (containerId === 'blood-cards') {
                                    // è¡€ç‰ŒåŒºå•æœºä¸é€‰æ‹©ï¼Œåªå¤„ç†åŒå‡»
                                } else {
                                    this.toggleCardSelection(card);
                                }
                            }
                        });
                    }

                    container.appendChild(cardElement);
                });
            }

            handleBloodCardDoubleClick(card, containerId) {
                const isSpecial = this.gameState.isSpecialCard(card);
                const isHeart = this.gameState.isHeartCard(card);
                
                if (isSpecial) {
                    this.gameState.selectSpecialCard(card);
                    this.showSpecialCardActions(containerId);
                } else if (isHeart) {
                    this.gameState.selectHeartCard(card);
                    this.showHeartCardActions(containerId);
                }
            }

            showSpecialCardActions(sourceContainer) {
                const specialActions = document.getElementById('special-card-actions');
                const moveToHandBtn = document.getElementById('move-to-hand');
                const moveToBloodBtn = document.getElementById('move-to-blood');
                
                if (sourceContainer === 'blood-cards') {
                    moveToHandBtn.disabled = false;
                    moveToBloodBtn.disabled = true;
                    moveToHandBtn.textContent = 'ğŸƒ ç§»å…¥æ‰‹ç‰Œ';
                    moveToBloodBtn.textContent = 'â¤ï¸ å·²åœ¨è¡€ç‰Œ';
                    moveToHandBtn.style.background = '#9b59b6';
                    moveToBloodBtn.style.background = '#7f8c8d';
                } else {
                    moveToHandBtn.disabled = true;
                    moveToBloodBtn.disabled = false;
                    moveToHandBtn.textContent = 'ğŸƒ å·²åœ¨æ‰‹ç‰Œ';
                    moveToBloodBtn.textContent = 'â¤ï¸ æ”¾å›è¡€ç‰Œ';
                    moveToHandBtn.style.background = '#7f8c8d';
                    moveToBloodBtn.style.background = '#9b59b6';
                }
                
                document.getElementById('heart-card-actions').classList.add('hidden');
                specialActions.classList.remove('hidden');
            }

            showHeartCardActions(sourceContainer) {
                const heartActions = document.getElementById('heart-card-actions');
                const retrieveHeartBtn = document.getElementById('retrieve-heart');
                
                if (sourceContainer === 'blood-cards') {
                    retrieveHeartBtn.disabled = false;
                    retrieveHeartBtn.textContent = 'ğŸƒ ç§»å…¥æ‰‹ç‰Œ';
                    retrieveHeartBtn.style.background = '#e74c3c';
                }
                
                document.getElementById('special-card-actions').classList.add('hidden');
                heartActions.classList.remove('hidden');
            }

            hideSpecialCardActions() {
                document.getElementById('special-card-actions').classList.add('hidden');
            }

            hideHeartCardActions() {
                document.getElementById('heart-card-actions').classList.add('hidden');
            }

            handleMoveToHand() {
                if (this.gameState.moveBloodToHand(this.gameState.selectedSpecialCard)) {
                    this.hideSpecialCardActions();
                    this.gameState.selectedSpecialCard = null;
                    this.render();
                }
            }

            handleMoveToBlood() {
                if (this.gameState.moveHandToBlood(this.gameState.selectedSpecialCard)) {
                    this.hideSpecialCardActions();
                    this.gameState.selectedSpecialCard = null;
                    this.render();
                }
            }

            handleRetrieveHeart() {
                if (this.gameState.retrieveHeartToHand(this.gameState.selectedHeartCard)) {
                    this.hideHeartCardActions();
                    this.gameState.selectedHeartCard = null;
                    this.render();
                }
            }

            cancelSpecialCardSelection() {
                this.gameState.selectedSpecialCard = null;
                this.hideSpecialCardActions();
            }

            cancelHeartCardSelection() {
                this.gameState.selectedHeartCard = null;
                this.hideHeartCardActions();
            }

            renderGameInfo() {
                document.getElementById('round').textContent = this.gameState.round;
                document.getElementById('phase').textContent = this.getPhaseText(this.gameState.phase);
            }

            renderLog() {
                const logContent = document.getElementById('log-content');
                logContent.innerHTML = '';

                this.gameState.gameLog.forEach(logEntry => {
                    const logElement = document.createElement('div');
                    logElement.className = 'log-entry';
                    logElement.textContent = `${logEntry.message}`;
                    logContent.appendChild(logElement);
                });

                logContent.scrollTop = logContent.scrollHeight;
            }

            toggleCardSelection(card) {
                if (!this.gameState.currentPlayer.isHuman) return;
                
                if (this.gameState.forceDiscardMode) {
                    const currentSelected = this.gameState.selectedCards.length;
                    const maxSelect = 2;
                    
                    const index = this.gameState.selectedCards.indexOf(card);
                    if (index > -1) {
                        this.gameState.selectedCards.splice(index, 1);
                    } else {
                        if (currentSelected < maxSelect) {
                            this.gameState.selectedCards.push(card);
                        } else {
                            alert('åªèƒ½é€‰æ‹©2å¼ ç‰Œå¼ƒæ‰ï¼');
                            return;
                        }
                    }
                } else {
                    const index = this.gameState.selectedCards.indexOf(card);
                    if (index > -1) {
                        this.gameState.selectedCards.splice(index, 1);
                    } else {
                        this.gameState.selectedCards.push(card);
                    }
                }
                
                this.render();
                this.updateActionButtons();
            }

            handlePlaceBlood() {
                if (this.gameState.forceDiscardMode) {
                    alert('è¯·å…ˆå®Œæˆå¼ƒç‰Œæ‘¸ç‰Œï¼');
                    return;
                }

                if (this.gameState.selectedCards.length !== 1) {
                    alert('è¯·é€‰æ‹©ä¸€å¼ çº¢å¿ƒç‰Œæ”¾ç½®åˆ°è¡€ç‰ŒåŒºï¼');
                    return;
                }

                const card = this.gameState.selectedCards[0];
                if (card.suit !== 'heart') {
                    alert('åªèƒ½æ”¾ç½®çº¢å¿ƒç‰Œåˆ°è¡€ç‰ŒåŒºï¼');
                    return;
                }

                if (this.gameState.placeBloodCard(card)) {
                    this.gameState.selectedCards = [];
                    this.render();
                }
            }

            handleNormalAttack() {
                if (this.gameState.forceDiscardMode) {
                    alert('è¯·å…ˆå®Œæˆå¼ƒç‰Œæ‘¸ç‰Œï¼');
                    return;
                }

                if (this.gameState.selectedCards.length === 0) {
                    alert('è¯·é€‰æ‹©è¦ç”¨äºæ”»å‡»çš„å¡ç‰Œï¼');
                    return;
                }

                const normalAttack = CardUtils.checkNormalAttack(this.gameState.selectedCards);
                if (!normalAttack) {
                    alert('è¯·é€‰æ‹©å•å¼ é»‘æ¡ƒç‰Œæˆ–å¯¹å­è¿›è¡Œæ™®é€šæ”»å‡»ï¼');
                    return;
                }

                this.showTargetSelection('normal');
            }

            handleSpecialAttack() {
                if (this.gameState.forceDiscardMode) {
                    alert('è¯·å…ˆå®Œæˆå¼ƒç‰Œæ‘¸ç‰Œï¼');
                    return;
                }

                if (this.gameState.selectedCards.length < 1) {
                    alert('è¯·é€‰æ‹©è¦ç”¨äºç‰¹æ®Šæ”»å‡»çš„å¡ç‰Œï¼');
                    return;
                }

                const availableCombos = CardUtils.checkCardCombos(this.gameState.selectedCards, this.gameState.players.filter(p => p.status !== 'dead').length);
                if (availableCombos.length === 0) {
                    alert('é€‰æ‹©çš„å¡ç‰Œæ— æ³•ç»„æˆæœ‰æ•ˆçš„ç‰Œå½¢ï¼');
                    return;
                }

                this.showComboSelection(availableCombos);
            }

            showComboSelection(combos) {
                const modal = document.getElementById('combo-selection');
                const comboOptions = document.getElementById('combo-options');
                const confirmButton = document.getElementById('confirm-combo');
                
                comboOptions.innerHTML = '';
                this.selectedCombo = null;
                confirmButton.disabled = true;
                
                combos.forEach(combo => {
                    const option = document.createElement('div');
                    option.className = 'combo-option';
                    option.innerHTML = `
                        <h4>${combo.name}</h4>
                        <p>${combo.description}</p>
                        <p>æ”»å‡»åŠ›: ${combo.power}</p>
                    `;
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.combo-option').forEach(el => {
                            el.classList.remove('selected');
                        });
                        option.classList.add('selected');
                        this.selectedCombo = combo.key;
                        confirmButton.disabled = false;
                    });
                    comboOptions.appendChild(option);
                });

                modal.classList.remove('hidden');
            }

            confirmComboSelection() {
                if (!this.selectedCombo) {
                    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç‰Œå½¢ï¼');
                    return;
                }
                
                document.getElementById('combo-selection').classList.add('hidden');
                this.showTargetSelection('special');
            }

            showTargetSelection(attackType) {
                const modal = document.getElementById('card-selection');
                const targetPlayers = document.getElementById('target-players');
                
                targetPlayers.innerHTML = '';
                
                this.gameState.otherPlayers.forEach(player => {
                    if (player.status !== 'unconscious' && player.status !== 'dead') {
                        const button = document.createElement('button');
                        button.textContent = `æ”»å‡» ${player.name} (è¡€ç‰Œ:${player.bloodCards.length})`;
                        button.addEventListener('click', () => {
                            this.selectedTarget = player.id;
                            modal.classList.add('hidden');
                            
                            if (attackType === 'normal') {
                                this.confirmNormalAttack();
                            } else if (attackType === 'special') {
                                this.executeSpecialAttack();
                            }
                        });
                        targetPlayers.appendChild(button);
                    }
                });

                modal.classList.remove('hidden');
            }

            confirmNormalAttack() {
                if (!this.selectedTarget) return;

                if (this.gameState.performNormalAttack(this.selectedTarget, this.gameState.selectedCards)) {
                    this.gameState.selectedCards = [];
                    this.render();
                }
                
                this.selectedTarget = null;
            }

            executeSpecialAttack() {
                if (!this.selectedTarget || !this.selectedCombo) {
                    alert('ç³»ç»Ÿé”™è¯¯ï¼šç¼ºå°‘ç›®æ ‡æˆ–ç‰Œå½¢ä¿¡æ¯');
                    return;
                }

                if (this.gameState.performSpecialAttack(this.selectedTarget, this.selectedCombo)) {
                    this.gameState.selectedCards = [];
                    this.gameState.selectedCombo = null;
                    this.render();
                }
                
                this.selectedTarget = null;
                this.selectedCombo = null;
            }

            cancelAttack() {
                document.getElementById('card-selection').classList.add('hidden');
                this.selectedTarget = null;
            }

            cancelComboSelection() {
                document.getElementById('combo-selection').classList.add('hidden');
                this.selectedCombo = null;
            }

            handleDiscardDraw() {
                if (this.gameState.forceDiscardMode) {
                    if (this.gameState.performForceDiscardDraw()) {
                        this.render();
                    }
                    return;
                }

                if (this.gameState.selectedCards.length < 2) {
                    alert('å¼ƒç‰Œæ‘¸ç‰Œéœ€è¦è‡³å°‘é€‰æ‹©2å¼ ç‰Œï¼');
                    return;
                }

                this.gameState.selectedCards.forEach(card => {
                    const index = this.gameState.currentPlayer.handCards.indexOf(card);
                    if (index > -1) {
                        const removedCard = this.gameState.currentPlayer.handCards.splice(index, 1)[0];
                        this.gameState.discardPile.push(removedCard);
                    }
                });

                this.gameState.addLog(`ğŸ—‘ï¸ ${this.gameState.currentPlayer.name}å¼ƒæ‰äº†${this.gameState.selectedCards.length}å¼ ç‰Œ`);

                const newCard = this.gameState.drawBasicCard();
                if (newCard) {
                    this.gameState.currentPlayer.handCards.push(newCard);
                    this.gameState.addLog(`ğŸƒ æ‘¸äº†ä¸€å¼ ç‰Œ`);
                }

                this.gameState.selectedCards = [];
                this.render();
            }

            updateActionButtons() {
                const player = this.gameState.currentPlayer;
                const isHumanTurn = player.isHuman;
                const hasSelectedCards = this.gameState.selectedCards.length > 0;
                const canNormalAttack = CardUtils.checkNormalAttack(this.gameState.selectedCards) !== null;
                const canFormCombo = CardUtils.checkCardCombos(this.gameState.selectedCards, this.gameState.players.filter(p => p.status !== 'dead').length).length > 0;
                
                if (this.gameState.forceDiscardMode) {
                    const canConfirmDiscard = this.gameState.selectedCards.length === 2;
                    
                    document.getElementById('place-blood-btn').disabled = true;
                    document.getElementById('attack-btn').disabled = true;
                    document.getElementById('special-attack-btn').disabled = true;
                    document.getElementById('equip-btn').disabled = true;
                    document.getElementById('discard-btn').disabled = !canConfirmDiscard;
                    document.getElementById('end-turn').disabled = true;
                    
                    document.getElementById('discard-btn').textContent = `ç¡®è®¤å¼ƒ2å¼ ç‰Œæ‘¸ç‰Œ`;
                    return;
                }
                
                if (player.status === 'dying') {
                    document.getElementById('place-blood-btn').disabled = !isHumanTurn || !(hasSelectedCards && this.gameState.selectedCards[0].suit === 'heart');
                    document.getElementById('attack-btn').disabled = true;
                    document.getElementById('special-attack-btn').disabled = true;
                    document.getElementById('equip-btn').disabled = true;
                    document.getElementById('discard-btn').disabled = true;
                    document.getElementById('end-turn').disabled = !isHumanTurn;
                } else {
                    document.getElementById('place-blood-btn').disabled = !isHumanTurn || !(hasSelectedCards && this.gameState.selectedCards[0].suit === 'heart');
                    document.getElementById('attack-btn').disabled = !isHumanTurn || !hasSelectedCards || !canNormalAttack || this.gameState.attackUsed;
                    document.getElementById('special-attack-btn').disabled = !isHumanTurn || !hasSelectedCards || !canFormCombo;
                    document.getElementById('equip-btn').disabled = true;
                    document.getElementById('discard-btn').disabled = !isHumanTurn || this.gameState.selectedCards.length < 2;
                    document.getElementById('end-turn').disabled = !isHumanTurn;
                }
                
                document.getElementById('discard-btn').textContent = 'ğŸ”„ å¼ƒç‰Œæ‘¸ç‰Œ';
            }

            getStatusText(status) {
                const statusTexts = { 
                    'normal': 'æ­£å¸¸', 
                    'unconscious': 'æ˜è¿·', 
                    'dying': 'æ¿’æ­»',
                    'dead': 'æ­»äº¡'
                };
                return statusTexts[status] || status;
            }

            getPhaseText(phase) {
                const phaseTexts = { 
                    'draw': 'æ‘¸ç‰Œ', 
                    'main': 'ä¸»è¦', 
                    'attack': 'æ”»å‡»', 
                    'end': 'ç»“æŸ' 
                };
                return phaseTexts[phase] || phase;
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            const gameState = new GameState(2);
            const uiManager = new UIManager(gameState);
            window.gameState = gameState;
        });
    </script>
</body>
</html>